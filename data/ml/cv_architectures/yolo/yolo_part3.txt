9. Что такое anchors и зачем они нужны? 
�
� Зачем они нужны 
• Без anchors (как в YOLOv1) каждая ячейка могла предсказать 
только один бокс фиксированной формы, что плохо при 
разных соотношениях сторон объектов. 
• Anchors позволяют: 
o ловить объекты разных размеров и форм в одной ячейке; 
o повысить точность и recall; 
o сделать обучение стабильным — сеть учится смещениям, 
а не абсолютным координатам. 
�
� Как это работает 
Для каждой ячейки grid и каждого anchor сеть предсказывает 4 
смещения: 
tx ,ty ,tw ,th   
и восстанавливает реальные координаты бокса: 
bx =σ(tx )+cx ,by =σ(ty )+cy ,bw =aw ⋅etw ,bh =ah ⋅eth   
где 
• (aw ,ah ) — размеры anchor box, 
• (cx ,cy ) — координаты ячейки grid, 
• σ(⋅) — сигмоида (ограничивает смещение в пределах ячейки). 
�
� Где берутся anchors 
• Обычно вычисляются K-Means кластеризацией по 
размеченным объектам датасета (метрика — 1 − IoU). 
• Для YOLOv3 берут 9 anchors, по 3 на каждый масштаб (stride 
8/16/32). 
Пример (COCO): 
Small:  (10,13), (16,30), (33,23) 
Medium: (30,61), (62,45), (59,119) 
Large:  (116,90), (156,198), (373,326) 
Кратко: 
Anchors — это шаблоны форм объектов. 
YOLO не предсказывает боксы напрямую, а корректирует anchors — 
сдвигает и масштабирует их, 
что ускоряет и стабилизирует детекцию объектов разных размеров. 
10. 
Как формируются координаты bbox из выходов сети (bx = 
sigmoid(tx) + cx и т. д.)? 
Сеть на каждом anchor предсказывает 4 значения: 
tx , ty , tw , th   
Дальше YOLO превращает их в реальные координаты бокса 
относительно всей картинки. 
1
️
⃣ Центр бокса (bx, by) 
YOLO ограничивает смещение центра в пределах одной ячейки grid с 
помощью sigmoid: 
bx =σ(tx )+cx ,by =σ(ty )+cy   
где 
• cx ,cy  — координаты ячейки на сетке (grid cell index), 
• σ(t) ∈ (0,1) — гарантирует, что центр бокса не “выскочит” за 
границы клетки. 
2
️
⃣ Ширина и высота (bw, bh) 
Размеры восстанавливаются как «масштабированный anchor»: 
bw =aw ⋅etw ,bh =ah ⋅eth   
где 
• aw ,ah  — размеры anchor box. 
Экспонента гарантирует, что ширина/высота всегда положительные. 
3
️
⃣ Перевод в пиксели исходного изображения 
Если уровень сетки имеет stride = S (8 / 16 / 32), то: 
Bx =bx ⋅S,By =by ⋅S,Bw =bw ⋅S,Bh =bh ⋅S  
Итог (очень кратко): 
YOLO берёт предсказанные смещения tx,ty,tw,tht_x, t_y, t_w, t_htx ,ty ,tw 
,th  и превращает их в реальный бокс через сигмоиду, экспоненту и 
anchor’ы. Центр ограничивается клеткой, размеры масштабируются 
через anchor. 
11. 
Почему используется sigmoid для tx, ty и objectness? 
Ограничение центра бокса внутри клетки grid. 
Sigmoid даёт значение в диапазоне (0, 1), то есть центр бокса всегда 
внутри своей ячейки: 
bx =σ(tx )+cx   
Это стабилизирует обучение — сеть не скачет между клетками и учит 
локальные смещения. 
Более стабильные градиенты. 
Для координат центра сеть предсказывает смещение, а не 
абсолютные координаты — это проще оптимизировать. 
�
� Почему sigmoid для objectness 
Objectness — это вероятность того, что в ячейке вообще есть объект, 
поэтому это по сути двухклассовая задача: 
объект vs фон 
Sigmoid идеально подходит: 
• преобразует логит → вероятность в диапазоне (0,1); 
• используется с BCE loss (binary cross entropy); 
• интуитивно интерпретируется как confidence score. 
Итог: 
• Sigmoid для tx, ty — чтобы предсказывать локальные смещения в 
пределах клетки grid. 
• Sigmoid для objectness — потому что это вероятность наличия 
объекта (binary classification). 
12. 
Как объединяются три уровня предсказаний? 
YOLOv3 делает предсказания на трёх масштабах: 
• 52×52 — мелкие объекты 
• 26×26 — средние 
• 13×13 — крупные 
Каждый уровень имеет форму: 
(bs, 3, H, W, 5 + C) 
Их не склеивают по размеру, потому что spatial разные. 
Вместо этого объединение происходит после перевода в реальные 
координаты (x, y, w, h) всех боксов. 
�
� Этапы объединения 
1
️
⃣ Каждый уровень переводится из grid-координат → в пиксели 
Используем: 
• сигмоиду, 
• экспоненту, 
• anchor’ы, 
• stride (8 / 16 / 32). 
После декодирования имеем списки боксов: 
pred_52 (мелкие) 
pred_26 (средние) 
pred_13 (крупные) 
Все они в одной системе координат (размер оригинальной картинки). 
2️⃣ Склейка в один большой список боксов 
Просто конкатенация по измерению anchor×grid: 
all_preds = torch.cat([pred_13, pred_26, pred_52], dim=1) 
 
Форма: 
(bs, N_total, 5 + C) 
 
где N_total = 
• 13×13×3 
•  
o 26×26×3 
•  
o 52×52×3 
Итого: 
13*13*3 = 507 
26*26*3 = 2028 
52*52*3 = 8112 
Всего: 10647 боксов на картинку 
 
 
3️⃣ Применяем NMS (Non-Max Suppression) 
Удаляем дубли и оставляем лучшие боксы: 
final_boxes = NMS(all_preds) 
 
 
�
� Итог в одно предложение 
YOLOv3 объединяет три уровня предсказаний после декодирования, 
просто конкатенируя все боксы в общий список и затем применяя 
NMS. 
13. 
Как создаётся target-тензор: matching GT-боксов с anchors 
(по IoU)? 
В YOLOv3 таргеты формируются в несколько этапов: 
1. Мы знаем: 
• GT-бокс: (x, y, w, h, class) 
• Anchors: набор фиксированных размеров 
• Три scale-а — 13×13, 26×26, 52×52 
(stride = 32, 16, 8) 
2. Для каждого GT-бокса считаем IoU со ВСЕМИ anchors 
Но без учёта положения, только по ширине и высоте 
(IoU между прямоугольниками, центр у обоих = (0,0)). 
→ Это позволяет понять: какой anchor лучше всего соответствует 
данному GT. 
3. Выбираем anchor с максимальным IoU 
Это anchor “ответственный” за GT-бокс. 
4. Переходим на нужный scale 
Если лучший anchor относится к scale 26×26 — формируем таргет 
именно на нём. 
5. Определяем ячейку grid 
Координаты центра GT: 
gx = x * grid_w 
gy = y * grid_h 
Целевая ячейка: 
gi = int(gx) 
gj = int(gy) 
6. В target-тензоре: 
Размер target: 
[bs, num_anchors, grid_h, grid_w, 5 + num_classes] 
Записываем: 
tx = gx - gi 
ty = gy - gj 
tw = log(gw / anchor_w) 
th = log(gh / anchor_h) 
objectness = 1 
class = one-hot 
То есть YOLO говорит модели: 
• где в пределах ячейки находится центр (tx, ty), 
• насколько шире/уже GT по сравнению с anchor (tw, th). 
7. Остальные anchors и ячейки получают objectness = 0 
Это создаёт полный target для всех трёх scale-ов.