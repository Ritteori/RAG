61. Что такое "проблема склеивания объектов" (Bounding Box Merging) 
и как ее решают (Non-Maximum Suppression)? 
Суть проблемы: 
Когда детектор объекта находит несколько перекрывающихся ограничивающих рамок 
(bounding boxes) для одного и того же объекта. Это происходит потому, что: 
1. Скользящее окно или anchor boxes могут генерировать несколько кандидатов 
для одного объекта 
2. Соседние ячейки в YOLO или SSD могут детектировать один объект 
3. Разные уровни feature maps могут дублировать детекции 
Визуализация проблемы: 
Исходное изображение:    [ Кот ] 
Детектор выдает:
         [ [Кот] , [Кот] , [Кот] ] 
(3 рамки на одном объекте) 
Решение: Non-Maximum Suppression (NMS) 
Цель NMS: Оставить только одну наилучшую ограничивающую рамку для каждого 
объекта. 
Алгоритм NMS шаг за шагом: 
1. Сортировка по уверенности: 
bboxes = [ 
[x1, y1, x2, y2, confidence=0.95, class="cat"],  # Лучшая 
[x1, y1, x2, y2, confidence=0.88, class="cat"],  # Хуже 
[x1, y1, x2, y2, confidence=0.76, class="cat"]   # Еще хуже 
] 
bboxes.sort(key=lambda x: x[4], reverse=True)  # Сортировка по confidence 
2. Выбор кандидатов и подавление дубликатов: 
selected_boxes = [] 
while bboxes: 
# Берем рамку с наибольшей уверенностью 
best_box = bboxes.pop(0) 
selected_boxes.append(best_box) 
# Удаляем все рамки, сильно перекрывающиеся с best_box 
bboxes = [ 
box for box in bboxes  
if iou(best_box, box) < threshold  # threshold обычно 0.5-0.7 
] 
3. Функция IoU (Intersection over Union): 
def iou(box1, box2): 
# Вычисление площади пересечения 
x_left = max(box1[0], box2[0]) 
y_top = max(box1[1], box2[1]) 
x_right = min(box1[2], box2[2]) 
y_bottom = min(box1[3], box2[3]) 
intersection = max(0, x_right - x_left) * max(0, y_bottom - y_top) 
# Вычисление площади объединения 
area1 = (box1[2] - box1[0]) * (box1[3] - box1[1]) 
area2 = (box2[2] - box2[0]) * (box2[3] - box2[1]) 
union = area1 + area2 - intersection 
return intersection / union 
Параметры NMS 
• IoU threshold: Обычно 0.5-0.7 
o Меньшее значение (0.3) → более агрессивное подавление 
o Большее значение (0.7) → более консервативное подавление 
• Confidence threshold: Минимальная уверенность для рассмотрения кандидата 
Пример работы 
До NMS: 
BBox 1: [10, 10, 50, 50] confidence=0.95, class=cat 
BBox 2: [12, 12, 48, 48] confidence=0.88, class=cat  # IoU=0.85 → удаляется 
BBox 3: [60, 60, 100, 100] confidence=0.92, class=dog # IoU=0.05 → сохраняется 
После NMS (threshold=0.5): 
BBox 1: [10, 10, 50, 50] confidence=0.95, class=cat 
BBox 3: [60, 60, 100, 100] confidence=0.92, class=dog 
Улучшенные версии NMS 
1. Soft-NMS: Вместо полного удаления уменьшает confidence перекрывающихся 
рамок 
2. DIoU-NMS: Учитывает расстояние между центрами рамок 
3. Adaptive-NMS: Динамический threshold в зависимости от плотности объектов 
Проблемы базового NMS: 
• Может подавлять близко расположенные объекты 
• Чувствителен к выбору threshold 
• Может удалять частично перекрывающиеся объекты разных классов 
Важность: NMS — критически важный постобработчик для большинства 
современных детекторов, улучшающий точность и очищающий вывод модели от 
дубликатов.