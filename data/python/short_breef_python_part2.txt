71. В чем разница между __str__ и __repr__? 
__repr__ — "официальное" строковое представление объекта, предназначенное в 
первую очередь для разработчиков. Его цель — быть однозначным, информативным 
и, где возможно, представлять собой корректный Python-код для воссоздания объекта. 
__str__ — "неформальное" строковое представление объекта, предназначенное для 
конечных пользователей. Его цель — быть читаемым и понятным. 
Ключевые различия: 
Критерий 
__repr__ 
__str__ 
Целевая 
аудитория 
Разработчики, отладка 
Пользователи, интерфейс 
Требования 
Однозначность, полнота 
Читаемость, лаконичность 
Идеальный 
вывод 
ClassName(param1=value1, param2=value2) 
Простое описание объекта 
Когда 
вызывается 
В REPL, при выводе коллекций, по 
умолчанию в print() если нет __str__ 
print(), str(), format(), f-строки 
Важные детали: 
1. Fallback-механизм: Если __str__ не определён, Python использует __repr__ 
вместо него. Обратное неверно. 
2. Требование к __repr__: Хорошая практика — возвращать строку, которую 
можно передать в eval() для создания аналогичного объекта (там, где это 
безопасно и разумно). 
3. Контексты использования: 
a. Отладка: Всегда используйте __repr__ для логирования и отладки 
b. Логи: В логах должен быть __repr__ для однозначной идентификации 
объектов 
c. Интерфейс: Для вывода пользователю используйте __str__ 
Практическое значение в ML-разработке: 
1. Отладка моделей: __repr__ позволяет быстро идентифицировать 
конфигурацию модели в логах 
2. Сериализация: Часто __repr__ используется для создания конфигурационных 
файлов 
3. Визуализация: __str__ используется в инструментах мониторинга и дашбордах 
4. Сравнение объектов: __repr__ даёт возможность быстрого сравнения 
конфигураций 
Главный принцип: __repr__ для машин и разработчиков, __str__ для людей и 
интерфейсов. 
72. Что такое менеджер контекста (with statement)? Как написать свой? 
Менеджер контекста (with statement) — это паттерн в Python для управления 
ресурсами, который гарантирует выполнение входных и выходных операций 
(например, открытие/закрытие файла, захват/освобождение блокировки). Его ключевое 
преимущество — надежность: он корректно обработает исключения и освободит 
ресурсы, даже если внутри блока with возникнет ошибка. 
Чтобы написать свой, нужно создать класс с двумя специальными методами: 
1. __enter__(self): Выполняется при входе в блок with. Может возвращать объект 
(например, открытый файл), который будет присвоен переменной после as. 
2. __exit__(self, exc_type, exc_val, exc_tb): Выполняется всегда при выходе из 
блока with, даже при исключении. Аргументы exc_* содержат информацию об 
ошибке, если она возникла. Метод отвечает за освобождение ресурсов и может 
подавить исключение, если вернет True. 
Альтернативно, можно использовать генератор и декоратор @contextmanager из 
модуля contextlib, что часто проще для не самых сложных сценариев. 
Базы данных:  
73. В чем разница между SQL и NoSQL? Приведите примеры.  
Основное различие лежит в модели данных, схеме и принципах масштабирования. 
• SQL (реляционные БД, например, PostgreSQL, MySQL): 
o Модель данных: Таблицы со строками и колонками. Связи между 
таблицами — через ключи (foreign keys). 
o Схема: Жесткая, схема определяется заранее (schema-on-write). 
o Язык: Стандартизированный SQL для сложных запросов с JOIN. 
o Масштабирование: В основном вертикальное (увеличение мощности 
сервера). 
o Гарантии: Следует принципам ACID (атомарность, согласованность, 
изоляция, долговечность), что критично для финансовых операций. 
o Использование: Системы, требующие надежности, сложных транзакций 
и согласованных запросов к связанным данным (банкинг, ERP). 
• NoSQL (нереляционные БД, например, MongoDB, Cassandra, Redis): 
o Модель данных: Разнообразная: документная (JSON-подобные 
структуры), ключ-значение, колоночная, графовая. 
o Схема: Гибкая, часто бессхемная (schema-on-read). Структура данных 
может меняться от записи к записи. 
o Язык: Специфичный для каждой БД (не SQL), часто через API. 
o Масштабирование: Горизонтальное (добавление большего числа 
серверов-нод), что удобно для больших данных. 
o Гарантии: Часто пожертвование строгой согласованностью (ACID) в 
пользу доступности и устойчивости к разделению (CAP-теорема), 
eventual consistency. 
o Использование: Высоконагруженные системы, где важны скорость, 
гибкость и объем: каталоги товаров, пользовательские профили, лог
данные, кэши (Redis), рекомендательные системы (графовые БД). 
74. Что такое нормализация базы данных?  
Нормализация — это процесс организации данных в реляционной базе данных с целью 
устранения избыточности и защиты от аномалий при вставке, обновлении и удалении 
данных (аномалии модификации). 
Она достигается путем декомпозиции больших таблиц на меньшие, связанные 
таблицы, и приведения их к стандартным нормальным формам (1NF, 2NF, 3NF, BCNF 
и далее). Каждая следующая форма ужесточает правила и устраняет конкретные типы 
проблем. 
Основные цели: 
1. Устранение дублирования данных (например, хранение адреса поставщика в 
каждой записи товара). 
2. Обеспечение целостности данных: Изменение данных происходит только в 
одном месте. 
3. Упрощение поддержки и внесения изменений. 
Простой пример: Вместо таблицы Заказы с повторяющимися полями Имя_клиента, 
Телефон_клиента для каждого заказа, мы создаем отдельную таблицу Клиенты и 
связываем ее с Заказами по client_id. Теперь данные о клиенте хранятся в одном месте. 
В контексте ML понимание нормализации помогает осознанно собирать и 
денормализировать данные для создания обучающих выборок. 
75. Напиши базовый SQL запрос с SELECT, WHERE, GROUP BY, HAVING, JOIN. 
SELECT 
d.department_name, 
COUNT(e.id) as employee_count, 
AVG(e.salary) as avg_salary 
FROM departments d 
JOIN employees e ON d.id = e.department_id 
WHERE e.hire_date > '2020-01-01' 
GROUP BY d.department_name 
HAVING AVG(e.salary) > 50000 
ORDER BY avg_salary DESC; 
Пояснение конструкции: 
1. SELECT: Выбираем название отдела и агрегаты по сотрудникам. 
2. FROM ... JOIN: Соединяем таблицы отделов и сотрудников по ключу. 
3. WHERE: Фильтруем строки до группировки (только недавно нанятые). 
4. GROUP BY: Группируем результаты по отделам для агрегации. 
5. HAVING: Фильтруем группы после агрегации (только отделы со средней 
зарплатой > 50000). 
6. ORDER BY: Сортируем финальный результат. 
Этот запрос демонстрирует осмысленное использование всех ключевых слов в 
правильной последовательности.