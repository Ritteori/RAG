Python и алгоритмы для ML 
1. Основы Python 
1. Чем отличаются списки (list) и кортежи (tuple)? 
Списки (list) — изменяемые последовательности объектов. Можно добавлять, 
удалять и изменять элементы. Создаются с помощью квадратных скобок: 
my_list = [1, 2, 3] 
Кортежи (tuple) — неизменяемые последовательности объектов. После 
создания нельзя менять элементы. Создаются с помощью круглых скобок или без 
скобок: 
my_tuple = (1, 2, 3) 
my_tuple2 = 1, 2, 3 
Отличия: 
1. Изменяемость: list — mutable, tuple — immutable. 
2. Производительность: кортежи быстрее в переборе и занимают меньше 
памяти. 
3. Использование как ключ словаря: кортежи можно, списки нельзя. 
2. Как создать словарь (dict) в Python? 
Словарь — это структура данных «ключ–значение». 
• Ключи должны быть уникальными и неизменяемыми (строки, числа, 
кортежи без изменяемых объектов). 
• Значения могут быть любыми объектами. 
Способы создания: 
1. Через фигурные скобки 
my_dict = {'a': 1, 'b': 2} 
2. Через конструктор dict() 
my_dict2 = dict(a=1, b=2) 
3. Из списка пар (кортежей) 
my_dict3 = dict([('a', 1), ('b', 2)]) 
4. Через словарное включение (dict comprehension) 
my_dict4 = {x: x**2 for x in range(5)} 
# Результат: {0:0, 1:1, 2:4, 3:9, 4:16} 
Доступ и изменение: 
print(my_dict['a'])  # доступ по ключу → 1 
my_dict['c'] = 3     
# добавление нового ключа и значения 
my_dict['a'] = 10    
# изменение существующего значения 
Примечание: словари в Python >=3.7 сохраняют порядок добавления элементов. 
3. Как работают множества (set) и где их удобно применять? 
• Mutable, неупорядоченная коллекция уникальных элементов. 
• Создание: 
# Через фигурные скобки 
s = {1, 2, 3} 
# Через конструктор set() из списка, строки и др. 
s2 = set([1, 2, 2, 3])   # {1, 2, 3} 
s3 = set('hello')         
# {'h', 'e', 'l', 'o'} 
• Основные свойства и операции: 
o Все элементы уникальные 
o Поддерживаются стандартные операции множеств: 
a = {1, 2, 3} 
b = {2, 3, 4} 
a | b  # объединение → {1, 2, 3, 4} 
a & b  # пересечение → {2, 3} 
a - b  # разность → {1} 
a ^ b  # симметричная разность → {1, 4} 
• Применение: удобно, когда нужны уникальные элементы, проверка 
принадлежности, удаление дубликатов или операции над множествами. 
4. Что такое list comprehension? Приведи пример. 
List comprehension — удобный способ создавать списки в одну строку, часто 
заменяет цикл for с .append(). 
Синтаксис: 
[выражение for элемент in итерируемый_объект if 
условие_необязательное] 
Примеры: 
# Простейший пример 
a = [x for x in range(10)]  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
# С условием 
b = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8] 
# С функцией 
c = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16] 
# Можно использовать lambda или другие функции 
d = [(lambda y: y*2)(x) for x in range(5)]  # [0, 2, 4, 6, 8] 
Преимущества: компактность, читаемость, возможность добавлять фильтры и 
функции прямо в выражение. 
5. Что такое генератор (generator) и как он отличается от списка? 
• Генератор — объект, который лениво (по требованию) выдаёт элементы 
последовательности, вместо того чтобы хранить весь список в памяти. 
• Создаются с помощью генераторных выражений или функций с yield. 
Примеры: 
1. Генераторное выражение (аналог list comprehension, но лениво) 
gen = (x**2 for x in range(5)) 
print(next(gen))  # 0 
print(next(gen))  # 1 
# и так далее, элементы создаются по мере запроса 
2. Функция-генератор с yield 
def my_gen(n): 
for i in range(n): 
yield i*2 
Отличие от списка: 
• Список хранит все элементы сразу: [0,1,4,9,16]. 
• Генератор выдаёт элементы по одному и экономит память, особенно на 
больших последовательностях. 
6. Как работают функции в Python? Что такое аргументы по 
умолчанию? 
• Синтаксис: 
def function_name(param1, param2=default_value): 
""" 
Описание функции 
""" 
# тело функции 
return result  # return необязателен; по умолчанию возвращается 
None 
• Аргументы: 
o Позиционные и именованные. 
o Аргументы по умолчанию задаются в определении функции: 
def greet(name, msg="Hello"): 
print(f"{msg}, {name}!") 
greet("Alice")          
# Hello, Alice! 
greet("Bob", msg="Hi")  # Hi, Bob! 
o Параметры с дефолтными значениями должны идти после 
обязательных. 
• Передача аргументов: 
o Изменяемые объекты (list, dict) внутри функции могут изменяться. 
o Неизменяемые объекты (int, str, tuple) не изменяются внутри 
функции. 
• Возвращаемое значение: 
o Через return. 
o Если return нет, функция возвращает None. 
7. Что такое лямбда-функции? 
• Анонимная функция: функция без имени, обычно используется для 
одноразовых компактных операций. 
• Синтаксис: 
lambda параметры: выражение 
Примеры: 
1. Простейший пример: 
square = lambda x: x**2 
print(square(5))  # 25 
2. Использование в map: 
nums = [1, 2, 3, 4] 
squares = list(map(lambda x: x**2, nums)) 
print(squares)  # [1, 4, 9, 16] 
3. Использование в filter: 
nums = [1, 2, 3, 4, 5] 
evens = list(filter(lambda x: x % 2 == 0, nums)) 
print(evens)  # [2, 4] 
4. Использование в sorted с ключом: 
words = ["apple", "banana", "cherry"] 
sorted_words = sorted(words, key=lambda w: len(w)) 
print(sorted_words)  # ['apple', 'cherry', 'banana'] 
• Компактны, читаемы для небольших функций. 
• Не рекомендуется использовать для сложной логики — лучше обычная def. 
8. Как импортировать модуль и вызвать функцию из него? 
1. Импорт всего модуля 
import math 
print(math.sqrt(16))  # 4.0 
2. Импорт конкретной функции 
from math import sqrt 
print(sqrt(16))  # 4.0 
3. Импорт с псевдонимом 
import numpy as np 
arr = np.array([1,2,3]) 
4. Импорт всех функций из модуля (не рекомендуется) 
from math import * 
print(sin(0))  # 0.0 
Примечание: from module import func позволяет использовать функцию 
напрямую, без префикса модуля. 
9. Что такое исключения и как их обрабатывать? 
• Исключения — ошибки, возникающие во время выполнения программы. 
• Обработка с помощью try/except: 
try: 
result = 10 / 0 
except ZeroDivisionError: 
print("Деление на ноль запрещено") 
except Exception as e:   # любой другой тип исключения 
print("Произошла ошибка:", e) 
else: 
print("Ошибок нет, результат:", result) 
finally: 
print("Этот блок выполняется всегда") 
• Блоки: 
o try — код, который может вызвать ошибку 
o except — обработка ошибок 
o else — выполняется, если ошибок нет 
o finally — выполняется в любом случае 
• Позволяет безопасно управлять ошибками и предотвращать аварийное 
завершение программы. 
10.Чем отличаются методы append() и extend() у списков? 
• append(obj) — добавляет один объект в конец списка. 
lst = [1,2,3] 
lst.append(4) 
print(lst)  # [1,2,3,4] 
lst.append([5,6]) 
print(lst)  # [1,2,3,4,[5,6]]  <- добавился целый список как элемент 
 
• extend(iterable) — добавляет все элементы итерируемого объекта в 
конец списка. 
lst = [1,2,3] 
lst.extend([4,5]) 
print(lst)  # [1,2,3,4,5] 
 
Ключевое отличие: 
• append — один объект целиком; 
• extend — «распаковывает» итерируемый объект и добавляет элементы по 
отдельности.