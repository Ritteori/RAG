2. Структуры данных  
11.Как реализовать стек (stack) на списках? 
Стек (stack) — структура данных типа LIFO (Last In – First Out): последний 
добавленный элемент извлекается первым. 
 Аналогия: стопка тарелок — чтобы достать нижнюю, надо убрать все верхние. 
Реализация на Python через list 
class Stack: 
    def __init__(self, array=None): 
        self.array = array if array is not None else [] 
 
    def __len__(self): 
        return len(self.array) 
     
    def push(self, x): 
        """Добавить элемент в стек""" 
        self.array.append(x) 
     
    def pop(self): 
        """Извлечь последний добавленный элемент""" 
        return self.array.pop() 
 
12.Что такое очередь (queue) и как её реализовать в Python? 
Очередь — это структура данных, работающая по принципу FIFO (First In — First 
Out): первый вошёл — первый вышел. 
 Пример из жизни: очередь людей в магазине. Тот, кто пришёл первым, 
обслуживается первым. 
Реализация через list 
class Queue: 
    def __init__(self, array: list = None): 
        if array is None: 
            array = [] 
        self.array = array 
 
    def __len__(self): 
        return len(self.array) 
 
    def enqueue(self, x):  # добавление в конец 
        self.array.append(x) 
 
    def dequeue(self):     # извлечение из начала 
        return self.array.pop(0) 
 
     Здесь: 
• enqueue — помещает элемент в конец очереди. 
• dequeue — извлекает элемент из начала очереди (по индексу 0). 
 
13.Чем отличается очередь с приоритетом (priority queue)? 
• Обычная очередь работает по принципу FIFO — первый пришёл, первый 
ушёл. 
• Очередь с приоритетом вместо этого "достаёт" элемент с наивысшим 
приоритетом. 
То есть порядок выхода определяется не временем добавления, а 
"важностью" элемента. 
�
� Пример 
Представь больницу: 
• Обычная очередь — пациенты заходят к врачу по порядку прихода. 
• Очередь с приоритетом — сначала заходят тяжёлые пациенты, даже если 
пришли позже. 
�
� Реализация 
• Обычно реализуется через кучу (heap) — например, бинарную кучу. 
• В Python есть готовый модуль heapq, который позволяет работать с 
приоритетами. 
import heapq 
pq = []  # очередь с приоритетом 
heapq.heappush(pq, (2, "task low priority")) 
heapq.heappush(pq, (1, "task high priority")) 
heapq.heappush(pq, (3, "task very low priority")) 
while pq: 
priority, task = heapq.heappop(pq) 
print(task) 
Вывод: 
task high priority 
task low priority 
task very low priority 
Потому что heapq достаёт сначала наименьший приоритет (1 лучше, чем 2 и 
3). 
 
⚡ Главное отличие 
• Обычная очередь = порядок зависит от времени добавления. 
• Очередь с приоритетом = порядок зависит от приоритета. 
 
14.Как реализовать хэш-таблицу? 
Определение: 
 Хэш-таблица — структура данных, которая хранит пары (ключ, значение) и 
позволяет быстро искать элемент по ключу (обычно за O(1) амортизированно). 
Принцип работы: 
1. Берём ключ. 
2. Пропускаем через хэш-функцию, получаем индекс в массиве. 
3. Вставляем значение в этот индекс. 
4. Если возникает коллизия (два ключа дали один индекс): 
a. метод цепочек (chaining) — храним список пар в этом индексе 
b. или метод открытой адресации (probing) — ищем следующий 
свободный индекс 
Простейшая реализация на Python: 
class HashTable: 
    def __init__(self, size=10): 
        self.size = size 
        self.table = [[] for _ in range(size)]  # массив списков 
 
    def _hash(self, key): 
        return hash(key) % self.size 
 
    def set(self, key, value): 
        idx = self._hash(key) 
        # обновляем если ключ уже есть 
        for pair in self.table[idx]: 
            if pair[0] == key: 
                pair[1] = value 
                return 
        self.table[idx].append([key, value]) 
 
    def get(self, key): 
        idx = self._hash(key) 
        for pair in self.table[idx]: 
            if pair[0] == key: 
                return pair[1] 
        return None 
 
     Вывод: 
• Python dict — это готовая хэш-таблица с оптимизациями. 
• Основная идея: хэшируем ключ → индекс → храним значение. 
 
15.Что такое связный список? 
Определение: 
 Связный список — это структура данных, состоящая из узлов (nodes), где каждый 
узел хранит: 
1. Значение (data) 
2. Ссылку на следующий узел (next) 
• Первый узел называется head. 
• Последний узел указывает на None. 
• Можно реализовать однонаправленный и двунаправленный список (next 
+ prev). 
Основное отличие от массива: 
• Массив — элементы в памяти идут подряд, быстрый доступ по индексу O(1), 
но вставка/удаление O(n). 
• Связный список — элементы могут быть в разных местах памяти, доступ по 
индексу O(n), но вставка/удаление в середину/начало O(1) при наличии 
ссылки на узел. 
 
Пример на Python 
class Node: 
    def __init__(self, data): 
        self.data = data 
        self.next = None 
 
class LinkedList: 
    def __init__(self): 
        self.head = None 
 
    def append(self, data): 
        new_node = Node(data) 
        if not self.head: 
            self.head = new_node 
            return 
        current = self.head 
        while current.next: 
            current = current.next 
        current.next = new_node 
 
    def print_list(self): 
        current = self.head 
        while current: 
            print(current.data, end=" -> ") 
            current = current.next 
        print("None") 
 
# Использование 
ll = LinkedList() 
ll.append(1) 
ll.append(2) 
ll.append(3) 
ll.print_list()  # 1 -> 2 -> 3 -> None 
 
 
      Итого: 
• Связный список удобен, когда много вставок/удалений. 
• Прямой доступ по индексу медленный, но можно легко менять структуру. 
 
16.Как реализовать бинарное дерево поиска (BST)? 
 
17.Как работает хеширование в словарях Python? 
18.Что такое граф? Какие типы графов бывают? 
19.Чем отличается ориентированный граф от неориентированного? 
20.Что такое цикл в графе?