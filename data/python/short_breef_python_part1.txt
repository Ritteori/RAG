Раздел 6: Инженерия и Кодирование (Software Engineering for ML) 
Python:  
68. В чем разница между списком (list) и кортежем (tuple)?  
Список (list) и кортеж (tuple) — основные коллекции в Python с фундаментальными 
различиями: 
1. Изменяемость (Mutability) 
• List: Изменяемый (mutable) — можно добавлять, удалять, изменять элементы 
• Tuple: Неизменяемый (immutable) — нельзя менять после создания 
2. Производительность и память 
• Tuple: Быстрее, меньше памяти (фиксированный размер) 
• List: Медленнее, больше памяти (динамическое расширение)  
3. Использование 
• List: Для однородных данных, когда количество элементов может меняться 
• Tuple: Для гетерогенных данных, фиксированных структур 
4. Хэшируемость 
• Tuple: Хэшируем (если все элементы хэшируемы) → можно использовать как 
ключ словаря 
• List: Не хэшируем → нельзя использовать как ключ словаря 
5. Методы 
• List: Много методов для модификации (append(), extend(), pop(), sort()) 
• Tuple: Минимальные методы (count(), index()) 
6. Семантика 
• List: "Коллекция" — порядок может иметь значение 
• Tuple: "Структура" — позиция имеет смысл (как поля в struct) 
Когда что использовать: 
• List: Когда нужно изменять коллекцию (добавлять/удалять элементы) 
• Tuple: Для константных данных, возврата из функций, ключей словарей 
69. Что такое генераторы (generators) и чем они отличаются от списков? 
Зачем они нужны?  
Генератор — это функция с ключевым словом yield. Она возвращает итератор, 
который генерирует значения лениво (lazy), по одному по мере запроса. Список 
хранит все значения в памяти сразу. 
Ключевые отличия: 
1. Память и инициализация: 
• Список: Создаётся и хранится в памяти целиком сразу. Для больших данных 
(миллионы элементов) это требует много оперативной памяти. 
• Генератор: Не хранит всю последовательность. Он "помнит" только текущее 
состояние (значение и точку выполнения функции) и генерирует следующий 
элемент, когда его запрашивают (через next() или цикл for). Потребляет 
минимальный объем памяти. 
2. Механизм работы: 
• Список: Вычисление всех элементов происходит в момент создания списка 
(например, при выполнении [x*x for x in range(1000000)]). 
• Генератор: Элементы вычисляются "на лету". Когда код доходит до yield, 
функция приостанавливается, возвращает значение, и замораживает своё 
состояние (все локальные переменные). При следующем запросе она 
возобновляет работу с того же места. 
3. Практическое следствие (одноразовость): 
• Список: Можно итерироваться по нему многократно. Он хранится в памяти и 
всегда доступен. 
• Генератор: Чаще всего является одноразовым итератором. После того как все 
значения были получены (достигнут конец функции или StopIteration), 
генератор считается исчерпанным. Повторный проход по нему не даст 
результатов. Чтобы пройти снова, нужно создать новый генератор. 
Зачем это нужно (особенно в ML): 
1. Работа с данными, которые не помещаются в память. Самая главная причина. 
Можно читать и обрабатывать огромные файлы (гигабайты) построчно или создавать 
пайплайны для потоковой передачи данных в модель, не загружая весь датасет разом. 
2. Экономия ресурсов. Если на каком-то этапе обработки цепочки данных нужно 
прерваться (например, нашли искомое), генератор не будет тратить время и память на 
вычисление всех последующих элементов, которые не понадобятся. 
3. Генерация бесконечных последовательностей. Список не может быть 
бесконечным, а генератор — может (теоретически), например, для непрерывного 
чтения с датчика или генерации синтетических данных для обучения. 
4. Создание эффективных конвейеров данных. В современных фреймворках 
(Keras/TensorFlow, PyTorch) концепция генераторов лежит в основе DataLoader и 
подобных инструментов. Они позволяют параллельно загружать, аугментировать и 
подавать в модель батчи данных, пока модель обрабатывает предыдущие, что 
максимально эффективно использует GPU. 
Итог: Списки — для конечных, небольших коллекций, с которыми нужно работать 
многократно. Генераторы — для работы с большими или потенциально бесконечными 
потоками данных, где критичны расход памяти и возможность ленивых вычислений. 
70. Что такое декоратор (decorator)? Как написать свой?  
Декоратор — это функция высшего порядка, которая принимает другую функцию в 
качестве аргумента, добавляет к ней дополнительное поведение и возвращает новую, 
модифицированную функцию. Это реализация паттерна проектирования "Декоратор". 
Как написать свой декоратор: 
1. Базовый шаблон: 
python 
def my_decorator(func): 
def wrapper(*args, **kwargs): 
# Код, выполняемый ДО вызова функции 
result = func(*args, **kwargs)  # Вызов оригинальной функции 
# Код, выполняемый ПОСЛЕ вызова функции 
return result 
return wrapper 
2. Обязательные компоненты: 
• Приём функции: Декоратор получает func для обёртки 
• Внутренняя функция (wrapper): Создаётся внутри декоратора и фактически 
заменяет func 
• Возврат обёртки: Декоратор возвращает wrapper, а не оригинальную функцию 
3. Критически важные нюансы: 
• *args, **kwargs: Всегда используйте их во wrapper, чтобы декоратор работал с 
любыми функциями 
• functools.wraps: Сохраняет имя, документацию и другие метаданные 
оригинальной функции 
• Возврат значения: wrapper должен возвращать результат вызова func 
Почему декораторы важны в ML-инфраструктуре: 
1. Инструментирование кода: 
• Логирование: Автоматическое логирование вызовов функций, параметров, 
времени выполнения 
• Мониторинг: Сбор метрик производительности, отслеживание использования 
ресурсов 
• Отладка: Автоматический дамп состояния при ошибках 
2. Управление ресурсами: 
• Контекст выполнения: Автоматическое выделение/освобождение GPU памяти 
• Кэширование: Мемоизация результатов тяжёлых вычислений (обучение, 
инференс) 
• Пулы соединений: Управление подключениями к БД, распределённым 
системам 
3. Валидация и безопасность: 
• Проверка данных: Валидация входных данных перед передачей в модель 
• Контроль доступа: Проверка прав на выполнение операций 
• Сериализация: Автоматическая конвертация форматов данных 
4. Аспектно-ориентированное программирование: 
• Разделение бизнес-логики и сквозной функциональности (cross-cutting concerns) 
• Чистая архитектура без дублирования кода 
Расширенные сценарии: 
Декораторы с аргументами: Требуют дополнительного уровня вложенности — 
декоратор возвращает декоратор. 
Декораторы классов: Могут модифицировать или регистрировать классы, часто 
используются в веб-фреймворках и ORM. 
Цепочки декораторов: Порядок применения имеет значение — выполнение 
происходит снизу вверх. 
Встроенные декораторы Python: 
• @classmethod, @staticmethod — методы классов 
• @property — управление доступом к атрибутам 
• @functools.lru_cache — кэширование 
• @dataclasses.dataclass — автоматическая генерация методов 
Вывод: Декораторы — мощный инструмент метапрограммирования, позволяющий 
создавать модульные, поддерживаемые и расширяемые ML-системы. Их понимание 
критически важно для проектирования промышленной ML-инфраструктуры. 